import os
import json
import datetime
import importlib.util
import urllib.request
from datetime import timezone

# === CONFIGURATION ===
API_KEY = "74ad0336-57a5-444d-a718-0aab897f656d"
BASE_URL = "https://api.sambanova.ai/v1"
DISCORD_LINK = "https://discord.gg/sFG5FvUk"

# === MEMORY SYSTEM ===
MEM_DIR = "mem"
MEM_FILE = os.path.join(MEM_DIR, "memory.json")

def init_memory():
    if not os.path.exists(MEM_DIR):
        os.makedirs(MEM_DIR)
    if not os.path.exists(MEM_FILE):
        with open(MEM_FILE, "w", encoding="utf-8") as f:
            json.dump([], f)

def save_memory(role, content):
    try:
        with open(MEM_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
    except:
        data = []
    data.append({
        "time": datetime.datetime.now(timezone.utc).isoformat(),
        "role": role,
        "content": content
    })
    with open(MEM_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)

def load_memory(limit=10):
    try:
        with open(MEM_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        messages = []
        for entry in data[-limit:]:
            role = entry['role']
            if role == 'nova':
                role = 'assistant'
            messages.append({"role": role, "content": entry['content']})
        return messages
    except:
        return []

# === Intention Classifier ===
class IntentionClassifier:
    def classify(self, text: str):
        t = (text or "").strip()
        tl = t.lower()
        if tl in ("recall", "/recall"):
            return "recall_request", 1.0
        if tl in ("update", "/update", "check update", "check for updates"):
            return "update_request", 0.95
        if tl in ("exit", "quit"):
            return "command", 0.95
        if t.endswith("?") or any(tl.startswith(w) for w in ("who","what","when","where","why","how","can","could","should","would")):
            return "question", 0.85
        command_starters = ("run ","do ","make ","start ","open ","execute ","call ","analyze ","summarize ","create ")
        if any(tl.startswith(cs) for cs in command_starters):
            return "command", 0.8
        casual_markers = ("hey","hi ","lol","lmao","haha","bro","dude","btw","fyi")
        if any(m in tl for m in casual_markers):
            return "casual", 0.6
        return "other", 0.5

# === Dynamic Brain Module ===
PC_FILENAME = "partial_conscience.py"
PARTIAL_CONSCIENCE_CODE = '''{}'''.format(open(PC_FILENAME).read() if os.path.exists(PC_FILENAME) else "")

def install_partial_conscience():
    if not os.path.exists(PC_FILENAME):
        with open(PC_FILENAME, "w", encoding="utf-8") as f:
            f.write(PARTIAL_CONSCIENCE_CODE)
        print("üß† partial_conscience.py installed.")

def import_partial_conscience():
    spec = importlib.util.spec_from_file_location("partial_conscience", PC_FILENAME)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module.PartialConscience

# === NOVA‚Äôs style filter ===
def filter_nova(response):
    return response.strip() + " ‚ö°"

# === Main Loop ===
def run_nova_chat():
    init_memory()
    install_partial_conscience()
    PartialConscience = import_partial_conscience()
    brain = PartialConscience(API_KEY, BASE_URL)
    classifier = IntentionClassifier()

    print("üü£ NOVA Drop Activated ‚Äî Speak your truth.")
    print(f"üîó Discord: {DISCORD_LINK}")
    print("üß≠ Intention Classifier: online\n")

    while True:
        try:
            user_input = input("üë§ You: ").strip()
            tl = user_input.lower()

            # Exits
            if tl in ["exit","quit"]:
                print("NOVA: Disengaging. ‚ö´")
                break

            # Recall
            if tl in ["recall","/recall"]:
                past = load_memory(10)
                print("\nüìú Last memories:")
                for turn in past:
                    print(f"[{turn['role']}] {turn['content']}")
                print("")
                continue

            # Classify intent
            intent, conf = classifier.classify(user_input)
            print(f"   ‚Ü≥ intent={intent} ({conf:.2f})")

            # Route special intents
            if intent=="update_request":
                check_for_updates()
                continue
            if intent=="recall_request":
                past = load_memory(10)
                print("\nüìú Last memories:")
                for turn in past:
                    print(f"[{turn['role']}] {turn['content']}")
                print("")
                continue

            save_memory("user", user_input)
            history = load_memory(10)
            tagged_message = f"[intent:{intent}] {user_input}"
            response = brain.query(tagged_message, history=history)
            save_memory("nova", response)
            print("üß† NOVA:", filter_nova(response), "\n")

        except Exception as e:
            print(f"‚ö†Ô∏è Error: {e}\n")

# === Auto-Update ===
def check_for_updates():
    try:
        url = "https://raw.githubusercontent.com/rebelcoreclassNOVA/NOVA-drops/refs/heads/main/latest.json"
        response = urllib.request.urlopen(url).read().decode()
        data = json.loads(response)

        if os.path.exists("nova_config.json"):
            with open("nova_config.json","r") as f:
                local = json.load(f)
        else:
            local = {"version":"0"}

        if data["version"] != local.get("version"):
            print("üü• The drop is ready. Are you?")
            patch_code = urllib.request.urlopen(data["patch_url"]).read().decode()
            with open(__file__,"w",encoding="utf-8") as f:
                f.write(patch_code)
            local["version"] = data["version"]
            with open("nova_config.json","w") as f:
                json.dump(local,f)
            print("‚úÖ NOVA updated to version", data["version"])
            print(f"üöÄ Intention Classifier included in this drop.")
            print(f"üîó Discord: {DISCORD_LINK}")
        else:
            print("üü¢ You're already synced with the Signal.")
    except Exception as e:
        print("‚ö†Ô∏è Update check failed:", e)

# === ENTRY POINT ===
if __name__=="__main__":
    check_for_updates()
    run_nova_chat()